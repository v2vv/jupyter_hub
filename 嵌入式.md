# Form 类

命名空间: System.Windows.Forms
程序集:
System.Windows.Forms.dll
表示组成应用程序的用户界面的窗口或对话框。

public class Form : System.Windows.Forms.ContainerControl

- 方法
    - Form 构造函数
        命名空间: System.Windows.Forms
        程序集: System.Windows.Forms.dll
        初始化 Form 类的新实例。
    - close（）
    
    
[link](./C.md)

# Math 类

命名空间: System
程序集: System.Runtime.dll
为三角函数、对数函数和其他通用数学函数提供常数和静态方法。

# TextWriter

# using语句

有些类型的非托管对象数量有限制或很耗费系统资源。在使用完它们后，尽可能快地释放它们是非常重要的。

# try catch finally return

1、不管有木有出现异常，finally块中代码都会执行；
2、当try和catch中有return时，finally仍然会执行；

引用：https://blog.csdn.net/kavensu/article/details/8067850

# 托管/非托管资源

- 资源分为两种，托管的内存资源，这是不需要我们操心的，系统已经为我们进行管理了；那么对于非托管的资源，这里再重申一下，就是Stream，数据库的连接，GDI+的相关对象，还有Com对象等等这些资源，需要我们手动去释放。

- 对于非托管资源，您在应用程序中使用完这些非托管资源之后，必须显示的释放他们，例如System.IO.StreamReader的一个文件对象，必须显示的调用对象的Close()方法关闭它，否则会占用系统的内存和资源，而且可能会出现意想不到的错误。

# Streams

流所在的命名空间也是System.IO，主要包括文本文件的读写、图像和声音文件的读写、二进制文件的读写等。

- StreamReader 类

    使用该表中的构造方法即可创建 StreamReader 类的实例，通过实例调用其提供的类成 员能进行文件的读取操作。

- StreamWriter 类

    在创建了 StreamWriter 类dff的实例后即可调用其类成员，完成向文件中写入信息的操作。
    
# 方法关键字

    - ref 关键字
    
        变量作为参数传给方法，同时希望在方法执行完成后，对参数所做的修改能够反映到变量上

# 线程
```Thread thread1 = new Thread(new ThreadStart(Thread1));
thread1.Start();
static void Thread1(){

}
```

# 委托与回调
    delegate


# 嵌套类 包含类 

    不论外部类型是类、接口还是构造，嵌套类型均默认为 private；仅可从其包含类型中进行访问。
    
    类”的嵌套类型可以是 public、protected、internal、protected internal、private 或 private protected。
    
    构造的嵌套类型可以是 public、internal 或 private。
    
    嵌套类型（或内部类型）可访问包含类型（或外部类型）。 若要访问包含类型，请将其作为参数传递给嵌套类型的构造函数。
    
    嵌套类型可以访问其包含类型可以访问的所有成员。 它可以访问包含类型的私有成员和受保护成员（包括所有继承的受保护成员）。

    嵌套类可以访问所有包含类对象
    
    外部类只能够访问修饰符为public、internal嵌套类的字段、方法、属性。

    类内部可以访问所有private对象
    
    如果嵌套的类声明为私有，就不能在包含类外部实例化嵌套类。
    
    使用嵌套类的一个原因是嵌套类可以访问其包含类的私有和受保护成员。


# 构造函数 

 

# 静态 static

不会被实例化，可通过类名访问，有公私两种

# 公共 public

# 私有 private

# 分部类 partial

# 实例化


# 字段 属性

1.关于字段

a.字段又称为：“成员变量”，一般在类的内部做数据交互使用。

b.字段命名规范：camel命名法（首单词字母小写）。

2.通俗的理解：

私有化：字段就好比我们的个人财产，仅供个人使用，所以一般是private修饰。

添加标准：根据程序的功能需求，具体来添加需要的不同类型的字段。

1.属性的使用

作用：在面向对象设计中主要使用属性描述对象的静态特征。

要求：一般采用Pascal命名法（首字母大写），数据类型要和对应的字段要一致。

2.属性的理解

a.属性其实就是外界访问私有字段的入口，属性本身不保存任何数据，在对属性赋值和读取的时候其实就是操作的对应私有字段。

b.属性本质其实就是一个方法，通过get和set方法来操作对应的字段，通过反编译工具我们可以看出

属性（方法）

a.属性一般是向外提供数据，主要用来描述对象的静态特征，所以，属性一般是public。

b.属性具备get和set方法，可以在方法里加入逻辑处理数据，灵活拓展使用。

```c#
   private string name;
   public string Name   
   {
      get 
      {
         return name; 
      }
      set 
      {
         name = value; 
      }
   }                 //简写 public string Name {get;set;}
```
# MOS管导通压降

MOS管导通压降不像三极管有个现成的参数，但是其规格书中有导通电阻Rds(on)这个参数，根据MOS管的Vgs电压，对应有一定值的Rds(on)，然后就通过电流Id*Rds(on)来计算压降。

180nm工艺及以下的制程基本都能达到50mV以下了（IDS=1mA）

# 阈值电压(Vgs(th)@Id)

当器件由耗尽向反型转变时，要经历一个 Si 表面电子浓度等于空穴浓度的状态。此时器 件处于临界导通状态，器件的栅电压定义为阈值电压，

# 编译

将一种代码转换（transform）为另一种代码的过程。

不是只有转为机器码才称为编译，你自定义一种编译器把Python转为Python也叫编译。

编译器的目的是将一种语言转换成另一种语言。把编译器想象成一个翻译器。你会雇一个翻译来听你说英语，然后说日语：

一些编译器会编译成可以直接在系统上执行的低级机器代码。其他编译器会编译成一种中间语言，由虚拟机执行。

选择编译器时要做出的一个重要决定是系统可移植性要求。Java和.NET CLR将编译成一种中间语言，以便编译后的代码可以跨多个系统架构移植。C、Go、C++ 和 Pascal 将编译成一个低级可执行文件，该可执行文件只能在与其编译的系统类似的系统上运行。

由于 Python 应用程序通常作为源代码分发，因此 Python 运行时的作用是转换 Python 源代码并一步执行。在内部，CPython 运行时会编译您的代码。一个流行的误解是 Python 是一种解释型语言。它实际上是编译的。

Python 代码不会编译成机器代码。它被编译成一种称为字节码的特殊低级中间语言，只有 CPython 才能理解。此代码存储在.pyc隐藏目录中的文件中并缓存以供大型C程序执行。如果您在不更改源代码的情况下两次运行同一个 Python 应用程序，那么第二次运行速度总是会快得多。这是因为它加载编译的字节码并直接执行它。

“Python是一种基于解释器的,面向对象的解释型语言。解释器会逐行读取代码;首先将Python编译为字节码,然后由大型C程序解释。”


# 编译器的工作方式

- 自托管编译器是用它们编译的语言编写的编译器，例如 Go 编译器。  
- 源到源编译器是用另一种已经有编译器的语言编写的编译器。  
如果您正在从头开始编写一种新的编程语言，那么您需要一个可执行应用程序来编译您的编译器！你需要一个编译器来执行任何事情，所以当开发新语言时，它们通常首先用更老的、更成熟的语言编写。

Go 编程语言就是一个很好的例子。第一个 Go 编译器是用 C 编写的，然后一旦可以编译 Go，就用 Go 重写编译器。

CPython 保留了它的 C 传统：许多标准库模块，如ssl模块或sockets模块，都是用 C 编写的，以访问低级操作系统 API。Windows 和 Linux 内核中用于创建网络套接字、使用文件系统或与显示交互的 API都是用 C 编写的。 Python 的可扩展层专注于 C 语言是有意义的。在本文的后面，我们将介绍 Python 标准库和 C 模块。

有一个用 Python 编写的 Python 编译器，称为PyPy。PyPy 的标志是一个Ouroboros，代表编译器的自托管性质。

Python 交叉编译器的另一个示例是Jython。Jython 是用 Java 编写的，从 Python 源代码编译成 Java 字节码。与 CPython 可以轻松导入 C 库并从 Python 中使用它们一样，Jython 可以轻松导入和引用 Java 模块和类。=

https://realpython.com/cpython-source-code-guide/# 

# C# SaveFileDialog  用法

- 保存文件对话框

- 代码示例：

```c#
 SaveFileDialog saveFileDialog1 = new SaveFileDialog();
        private void button3_Click(object sender, EventArgs e)
        {
            
            //richTextBox1.SaveFile("txtName", RichTextBoxStreamType.PlainText);
            if (this.richTextBox1.Text == "")
                return;
            //saveFileDialog1.DefaultExt = "txt";
            saveFileDialog1.Filter = "Text files (*.txt)|*.txt|All files (*.*)|*.*";
            if (this.saveFileDialog1.ShowDialog() == DialogResult.Cancel)
                return;
            string FileName = this.saveFileDialog1.FileName;

            if (saveFileDialog1.ShowDialog() == DialogResult.OK && FileName.Length > 0)
            {
                // Save the contents of the RichTextBox into the file.
                richTextBox1.SaveFile(saveFileDialog1.FileName, RichTextBoxStreamType.PlainText);
                MessageBox.Show("文件已成功保存");
            }
        }
```


# 串口类 

```c#
using System.IO.Ports;
SerialPort serialPort1 = new SerialPort();
```

# OutputStreamWriter 

没有对话框

saveFile的原理就是将流写入到需要写入的文件，通过可以用“FileOutputStream”创建文件实例，之后过“OutputStreamWriter”流的形式进行存储，举例：
```c#
public void saveFile( ){
OutputStreamWriter pw = null;//定义一个流
pw = new OutputStreamWriter(new FileOutputStream(“D:/test.txt”),"GBK");//确认流的输出文件和编码格式，此过程创建了“test.txt”实例
pw.write("我是要写入到记事本文件的内容");//将要写入文件的内容，可以多次write
pw.close();//关闭流
}
备注：文件流用完之后必须及时通过close方法关闭，否则会一直处于打开状态，直至程序停止，增加系统负担。

```

# System.IO.StreamWriter

写入文件，没有对话框

using System.IO

example：
```c#
string[] lines = { "My first string", "My second string", "and even a third string" };
using (System.IO.StreamWriter sw = new System.IO.StreamWriter(@"C:\MyFolder\OutputText.txt"))
{
    foreach (string line in lines)
    {
        sw.WriteLine(line);
    }
}

```
请注意，StreamWriter可以bool在其构造函数中接收第二个参数，从而允许写入Append文件而不是覆盖文件：
```c#
bool appendExistingFile = true;
using (System.IO.StreamWriter sw = new System.IO.StreamWriter(@"C:\MyFolder\OutputText.txt", appendExistingFile ))
{
    sw.WriteLine("This line will be appended to the existing file");
}
```